<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Neuron Volume Renderer with LOD</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            overflow: hidden;
        }
        #canvas { width: 100vw; height: 100vh; display: block; }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 280px;
        }
        #info h1 { font-size: 16px; margin-bottom: 10px; color: #0af; }
        #info p { margin: 5px 0; color: #aaa; font-size: 12px; }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
        }
        #controls label { display: block; margin: 8px 0 3px; color: #aaa; font-size: 12px; }
        #controls input[type="range"] { width: 180px; }
        #controls button {
            margin: 5px 5px 5px 0;
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: #444;
            color: #fff;
            font-size: 12px;
        }
        #controls button:hover { background: #666; }
        #controls button.active { background: #0af; }
        #controls button.skeleton-active { background: #f0a; }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 18px;
        }
        .val { color: #0af; }
        .btn-group { margin-bottom: 5px; }
    </style>
</head>
<body>
    <div id="loading">Loading volume data...</div>
    <canvas id="canvas"></canvas>
    <div id="info" style="display:none;">
        <h1>3D Neuron Volume Renderer</h1>
        <p>Volume: <span class="val" id="volSize">-</span></p>
        <p>Mode: <span class="val" id="modeText">Reconstruction</span></p>
        <p>Zoom: <span class="val" id="zoomLevel">1.0x</span></p>
        <p>LOD: <span class="val" id="lodLevel">Full</span></p>
        <p>FPS: <span class="val" id="fps">-</span></p>
        <p style="margin-top: 10px;">Drag to rotate | Scroll to zoom</p>
    </div>
    <div id="controls" style="display:none;">
        <label>Brightness: <span id="brightnessVal">2.0</span></label>
        <input type="range" id="brightness" min="0.5" max="10" step="0.5" value="2">
        
        <label>Threshold: <span id="thresholdVal">0.02</span></label>
        <input type="range" id="threshold" min="0" max="0.3" step="0.01" value="0.02">
        
        <label>LOD Detail: <span id="lodDetailVal">1.0</span></label>
        <input type="range" id="lodDetail" min="0.2" max="2.0" step="0.1" value="1.0">
        
        <label>Render Mode</label>
        <div class="btn-group">
            <button id="mipBtn" class="active">MIP</button>
            <button id="alphaBtn">Alpha</button>
        </div>
        
        <label>Data Source</label>
        <div class="btn-group">
            <button id="recBtn" class="active">Recon</button>
            <button id="gtBtn">GT</button>
            <button id="diffBtn">Diff</button>
            <button id="skelBtn">Skeleton</button>
        </div>
        
        <label>LOD Mode</label>
        <div class="btn-group">
            <button id="lodAutoBtn" class="active">Auto</button>
            <button id="lodOffBtn">Off</button>
        </div>
        
        <label>Auto-Rotate</label>
        <button id="rotateBtn" class="active">On</button>
    </div>

    <script id="vs" type="x-shader/x-vertex">#version 300 es
in vec2 aPosition;
out vec2 vUV;
void main() {
    vUV = aPosition * 0.5 + 0.5;
    gl_Position = vec4(aPosition, 0.0, 1.0);
}</script>

    <script id="fs" type="x-shader/x-fragment">#version 300 es
precision highp float;
precision highp sampler3D;

in vec2 vUV;
out vec4 fragColor;

uniform sampler3D uVolume;
uniform sampler3D uVolumeGT;
uniform sampler3D uVolumeSkeleton;
uniform mat3 uRotation;
uniform float uZoom;
uniform float uBrightness;
uniform float uThreshold;
uniform int uRenderMode;
uniform int uDataSource;
uniform vec3 uAspect;
uniform vec2 uResolution;
uniform float uLODFactor;
uniform int uLODEnabled;

const int MAX_STEPS = 512;

vec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {
    vec3 tMin = (boxMin - rayOrigin) / rayDir;
    vec3 tMax = (boxMax - rayOrigin) / rayDir;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
}

void main() {
    vec2 uv = (vUV - 0.5) * 2.0;
    uv.x *= uResolution.x / uResolution.y;
    
    vec3 rayOrigin = vec3(0.0, 0.0, uZoom);
    vec3 rayDir = normalize(vec3(uv * 0.8, -1.0));
    
    rayOrigin = uRotation * rayOrigin;
    rayDir = uRotation * rayDir;
    
    vec3 boxMin = -uAspect * 0.5;
    vec3 boxMax = uAspect * 0.5;
    
    vec2 tHit = intersectAABB(rayOrigin, rayDir, boxMin, boxMax);
    
    if (tHit.x > tHit.y || tHit.y < 0.0) {
        fragColor = vec4(0.0, 0.0, 0.0, 1.0);
        return;
    }
    
    tHit.x = max(tHit.x, 0.0);
    
    float baseStepSize = 0.002;
    float stepSize = baseStepSize;
    if (uLODEnabled == 1) {
        float lodScale = clamp(uZoom / 2.0, 0.5, 2.0);
        stepSize = baseStepSize * lodScale * uLODFactor;
    }
    
    float maxVal = 0.0;
    float accumAlpha = 0.0;
    vec3 accumColor = vec3(0.0);
    
    int maxSteps = MAX_STEPS;
    if (uLODEnabled == 1) {
        float stepMultiplier = clamp(2.0 / uZoom, 0.5, 2.0);
        maxSteps = int(float(MAX_STEPS) * stepMultiplier / uLODFactor);
    }
    
    for (int i = 0; i < MAX_STEPS; i++) {
        if (i >= maxSteps) break;
        
        float t = tHit.x + float(i) * stepSize;
        if (t > tHit.y) break;
        
        vec3 pos = rayOrigin + rayDir * t;
        vec3 texCoord = (pos - boxMin) / (boxMax - boxMin);
        
        float valRec = texture(uVolume, texCoord).r;
        float valGT = texture(uVolumeGT, texCoord).r;
        float valSkel = texture(uVolumeSkeleton, texCoord).r;
        
        float adaptiveThreshold = uThreshold;
        if (uLODEnabled == 1) {
            adaptiveThreshold = uThreshold * clamp(uZoom / 2.0, 0.8, 1.5);
        }
        
        float val;
        vec3 color;
        
        if (uDataSource == 0) {
            // Reconstruction - grayscale
            val = max(0.0, valRec - adaptiveThreshold);
            color = vec3(val);
        } else if (uDataSource == 1) {
            // Ground Truth - grayscale
            val = max(0.0, valGT - adaptiveThreshold);
            color = vec3(val);
        } else if (uDataSource == 2) {
            // Difference - orange
            float absDiff = abs(valRec - valGT);
            val = max(0.0, absDiff - adaptiveThreshold * 0.3);
            color = vec3(val, val * 0.7, 0.0);
        } else {
            // Skeleton (3DGS) - magenta/pink
            val = max(0.0, valSkel - adaptiveThreshold);
            color = vec3(val, val * 0.3, val);
        }
        
        float opacityBoost = 1.0;
        if (uLODEnabled == 1 && stepSize > baseStepSize) {
            opacityBoost = stepSize / baseStepSize;
        }
        
        if (uRenderMode == 0) {
            maxVal = max(maxVal, val);
            if (uDataSource == 3 && val > maxVal - 0.001) {
                // Track color for skeleton MIP
            }
        } else {
            float alpha = val * 0.08 * opacityBoost;
            accumColor += (1.0 - accumAlpha) * color * alpha;
            accumAlpha += (1.0 - accumAlpha) * alpha;
            if (accumAlpha > 0.95) break;
        }
    }
    
    vec3 result;
    if (uRenderMode == 0) {
        if (uDataSource == 2) {
            result = vec3(maxVal, maxVal * 0.7, 0.0) * uBrightness * 3.0;
        } else if (uDataSource == 3) {
            // Skeleton - magenta MIP
            result = vec3(maxVal, maxVal * 0.3, maxVal) * uBrightness;
        } else {
            result = vec3(maxVal * uBrightness);
        }
    } else {
        result = accumColor * uBrightness;
    }
    
    fragColor = vec4(result, 1.0);
}</script>

    <script>
    (function() {
        var canvas = document.getElementById("canvas");
        var gl = canvas.getContext("webgl2");
        
        if (!gl) {
            document.getElementById("loading").textContent = "WebGL2 not supported";
            return;
        }

        var volumeTexture, volumeTextureGT, volumeTextureSkeleton;
        var program;
        var vao;
        var rotationX = 0.3;
        var rotationY = 0;
        var zoom = 2.0;
        var autoRotate = true;
        var renderMode = 0;
        var dataSource = 0;
        var brightness = 2.0;
        var threshold = 0.02;
        var lodDetail = 1.0;
        var lodEnabled = true;
        var volumeDims = {x: 820, y: 650, z: 100};
        var aspectRatio = {x: 1.0, y: 0.793, z: 0.122};
        var lastTime = performance.now();
        var frameCount = 0;

        function createShader(type, sourceId) {
            var source = document.getElementById(sourceId).textContent;
            var shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error("Shader error:", gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function createProgram(vsId, fsId) {
            var vs = createShader(gl.VERTEX_SHADER, vsId);
            var fs = createShader(gl.FRAGMENT_SHADER, fsId);
            var prog = gl.createProgram();
            gl.attachShader(prog, vs);
            gl.attachShader(prog, fs);
            gl.linkProgram(prog);
            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                console.error("Program error:", gl.getProgramInfoLog(prog));
                return null;
            }
            return prog;
        }

        function loadTexture3D(url) {
            return fetch(url)
                .then(function(resp) { return resp.arrayBuffer(); })
                .then(function(buffer) {
                    var data = new Uint8Array(buffer);
                    var tex = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_3D, tex);
                    gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
                    gl.texImage3D(
                        gl.TEXTURE_3D, 0, gl.R8,
                        volumeDims.x, volumeDims.y, volumeDims.z,
                        0, gl.RED, gl.UNSIGNED_BYTE, data
                    );
                    return tex;
                });
        }

        function loadVolumes() {
            return fetch("volume_dims.json")
                .then(function(resp) { return resp.json(); })
                .then(function(dims) {
                    volumeDims = dims;
                    aspectRatio = {
                        x: dims.aspect_x || 1.0,
                        y: dims.aspect_y || 1.0,
                        z: dims.aspect_z || 1.0
                    };
                    
                    console.log("Volume dimensions:", dims);
                    document.getElementById("volSize").textContent = dims.z + " x " + dims.y + " x " + dims.x;
                    
                    return Promise.all([
                        loadTexture3D("volume.raw"),
                        loadTexture3D("volume_gt.raw"),
                        loadTexture3D("volume_skeleton.raw")
                    ]);
                })
                .then(function(textures) {
                    volumeTexture = textures[0];
                    volumeTextureGT = textures[1];
                    volumeTextureSkeleton = textures[2];
                    console.log("All textures loaded (Recon, GT, Skeleton)");
                    return true;
                })
                .catch(function(e) {
                    console.error("Load error:", e);
                    document.getElementById("loading").textContent = "Error: " + e.message;
                    return false;
                });
        }

        function init() {
            program = createProgram("vs", "fs");
            
            var positions = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
            
            vao = gl.createVertexArray();
            gl.bindVertexArray(vao);
            
            var posBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
            
            var posLoc = gl.getAttribLocation(program, "aPosition");
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
        }

        function makeRotationMatrix(rx, ry) {
            var cx = Math.cos(rx), sx = Math.sin(rx);
            var cy = Math.cos(ry), sy = Math.sin(ry);
            return new Float32Array([
                cy,      0,   sy,
                sx*sy,   cx,  -sx*cy,
                -cx*sy,  sx,  cx*cy
            ]);
        }
        
        function updateLODInfo() {
            var zoomFactor = 2.0 / zoom;
            document.getElementById("zoomLevel").textContent = zoomFactor.toFixed(1) + "x";
            
            var lodLevel = "Full";
            if (lodEnabled) {
                if (zoom > 3.0) lodLevel = "Low";
                else if (zoom > 2.0) lodLevel = "Medium";
                else if (zoom < 1.0) lodLevel = "High";
                else lodLevel = "Full";
            } else {
                lodLevel = "Off";
            }
            document.getElementById("lodLevel").textContent = lodLevel;
        }

        function render() {
            frameCount++;
            var now = performance.now();
            if (now - lastTime >= 1000) {
                document.getElementById("fps").textContent = frameCount;
                frameCount = 0;
                lastTime = now;
            }
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            if (autoRotate) {
                rotationY += 0.005;
            }
            
            gl.useProgram(program);
            gl.bindVertexArray(vao);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_3D, volumeTexture);
            gl.uniform1i(gl.getUniformLocation(program, "uVolume"), 0);
            
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_3D, volumeTextureGT);
            gl.uniform1i(gl.getUniformLocation(program, "uVolumeGT"), 1);
            
            gl.activeTexture(gl.TEXTURE2);
            gl.bindTexture(gl.TEXTURE_3D, volumeTextureSkeleton);
            gl.uniform1i(gl.getUniformLocation(program, "uVolumeSkeleton"), 2);
            
            gl.uniformMatrix3fv(gl.getUniformLocation(program, "uRotation"), false, makeRotationMatrix(rotationX, rotationY));
            gl.uniform1f(gl.getUniformLocation(program, "uZoom"), zoom);
            gl.uniform1f(gl.getUniformLocation(program, "uBrightness"), brightness);
            gl.uniform1f(gl.getUniformLocation(program, "uThreshold"), threshold);
            gl.uniform1i(gl.getUniformLocation(program, "uRenderMode"), renderMode);
            gl.uniform1i(gl.getUniformLocation(program, "uDataSource"), dataSource);
            gl.uniform3f(gl.getUniformLocation(program, "uAspect"), aspectRatio.x, aspectRatio.y, aspectRatio.z);
            gl.uniform2f(gl.getUniformLocation(program, "uResolution"), canvas.width, canvas.height);
            gl.uniform1f(gl.getUniformLocation(program, "uLODFactor"), lodDetail);
            gl.uniform1i(gl.getUniformLocation(program, "uLODEnabled"), lodEnabled ? 1 : 0);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            updateLODInfo();
            
            requestAnimationFrame(render);
        }

        var isDragging = false;
        var lastMouseX, lastMouseY;

        canvas.addEventListener("mousedown", function(e) {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            autoRotate = false;
            document.getElementById("rotateBtn").classList.remove("active");
        });

        canvas.addEventListener("mousemove", function(e) {
            if (!isDragging) return;
            var dx = e.clientX - lastMouseX;
            var dy = e.clientY - lastMouseY;
            rotationY += dx * 0.01;
            rotationX += dy * 0.01;
            rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotationX));
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener("mouseup", function() { isDragging = false; });
        canvas.addEventListener("mouseleave", function() { isDragging = false; });

        canvas.addEventListener("wheel", function(e) {
            e.preventDefault();
            zoom *= e.deltaY > 0 ? 1.1 : 0.9;
            zoom = Math.max(0.3, Math.min(5, zoom));
        });

        canvas.addEventListener("touchstart", function(e) {
            if (e.touches.length === 1) {
                isDragging = true;
                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;
                autoRotate = false;
            }
        });

        canvas.addEventListener("touchmove", function(e) {
            e.preventDefault();
            if (isDragging && e.touches.length === 1) {
                var dx = e.touches[0].clientX - lastMouseX;
                var dy = e.touches[0].clientY - lastMouseY;
                rotationY += dx * 0.01;
                rotationX += dy * 0.01;
                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;
            }
        });

        canvas.addEventListener("touchend", function() { isDragging = false; });

        document.getElementById("brightness").addEventListener("input", function(e) {
            brightness = parseFloat(e.target.value);
            document.getElementById("brightnessVal").textContent = brightness.toFixed(1);
        });

        document.getElementById("threshold").addEventListener("input", function(e) {
            threshold = parseFloat(e.target.value);
            document.getElementById("thresholdVal").textContent = threshold.toFixed(2);
        });
        
        document.getElementById("lodDetail").addEventListener("input", function(e) {
            lodDetail = parseFloat(e.target.value);
            document.getElementById("lodDetailVal").textContent = lodDetail.toFixed(1);
        });

        document.getElementById("mipBtn").addEventListener("click", function() {
            renderMode = 0;
            document.getElementById("mipBtn").classList.add("active");
            document.getElementById("alphaBtn").classList.remove("active");
        });

        document.getElementById("alphaBtn").addEventListener("click", function() {
            renderMode = 1;
            document.getElementById("alphaBtn").classList.add("active");
            document.getElementById("mipBtn").classList.remove("active");
        });

        function clearDataSourceButtons() {
            document.getElementById("recBtn").classList.remove("active");
            document.getElementById("gtBtn").classList.remove("active");
            document.getElementById("diffBtn").classList.remove("active");
            document.getElementById("skelBtn").classList.remove("active");
            document.getElementById("skelBtn").classList.remove("skeleton-active");
        }

        document.getElementById("recBtn").addEventListener("click", function() {
            dataSource = 0;
            clearDataSourceButtons();
            document.getElementById("recBtn").classList.add("active");
            document.getElementById("modeText").textContent = "Reconstruction";
        });

        document.getElementById("gtBtn").addEventListener("click", function() {
            dataSource = 1;
            clearDataSourceButtons();
            document.getElementById("gtBtn").classList.add("active");
            document.getElementById("modeText").textContent = "Ground Truth";
        });

        document.getElementById("diffBtn").addEventListener("click", function() {
            dataSource = 2;
            clearDataSourceButtons();
            document.getElementById("diffBtn").classList.add("active");
            document.getElementById("modeText").textContent = "Difference (|Rec - GT|)";
        });

        document.getElementById("skelBtn").addEventListener("click", function() {
            dataSource = 3;
            clearDataSourceButtons();
            document.getElementById("skelBtn").classList.add("skeleton-active");
            document.getElementById("modeText").textContent = "Skeleton (3DGS)";
        });
        
        document.getElementById("lodAutoBtn").addEventListener("click", function() {
            lodEnabled = true;
            document.getElementById("lodAutoBtn").classList.add("active");
            document.getElementById("lodOffBtn").classList.remove("active");
        });
        
        document.getElementById("lodOffBtn").addEventListener("click", function() {
            lodEnabled = false;
            document.getElementById("lodOffBtn").classList.add("active");
            document.getElementById("lodAutoBtn").classList.remove("active");
        });

        document.getElementById("rotateBtn").addEventListener("click", function() {
            autoRotate = !autoRotate;
            document.getElementById("rotateBtn").classList.toggle("active", autoRotate);
        });

        init();
        loadVolumes().then(function(loaded) {
            if (loaded) {
                document.getElementById("loading").style.display = "none";
                document.getElementById("info").style.display = "block";
                document.getElementById("controls").style.display = "block";
                render();
            }
        });
    })();
    </script>
</body>
</html>
