<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Neuron Volume Renderer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            overflow: hidden;
        }
        #canvas { width: 100vw; height: 100vh; display: block; }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 280px;
        }
        #info h1 { font-size: 16px; margin-bottom: 10px; color: #0af; }
        #info p { margin: 5px 0; color: #aaa; font-size: 12px; }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
        }
        #controls label { display: block; margin: 8px 0 3px; color: #aaa; font-size: 12px; }
        #controls input[type="range"] { width: 180px; }
        #controls button {
            margin: 5px 5px 5px 0;
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: #444;
            color: #fff;
            font-size: 12px;
        }
        #controls button:hover { background: #666; }
        #controls button.active { background: #0af; }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 18px;
        }
        .val { color: #0af; }
    </style>
</head>
<body>
    <div id="loading">Loading volume data...</div>
    <canvas id="canvas"></canvas>
    <div id="info" style="display:none;">
        <h1>3D Neuron Volume Renderer</h1>
        <p>Volume: <span class="val" id="volSize">-</span></p>
        <p>FPS: <span class="val" id="fps">-</span></p>
        <p style="margin-top: 10px;">Drag to rotate | Scroll to zoom</p>
    </div>
    <div id="controls" style="display:none;">
        <label>Brightness: <span id="brightnessVal">2.0</span></label>
        <input type="range" id="brightness" min="0.5" max="10" step="0.5" value="2">
        
        <label>Threshold: <span id="thresholdVal">0.02</span></label>
        <input type="range" id="threshold" min="0" max="0.3" step="0.01" value="0.02">
        
        <label>Render Mode</label>
        <button id="mipBtn" class="active">MIP</button>
        <button id="alphaBtn">Alpha</button>
        
        <label>Auto-Rotate</label>
        <button id="rotateBtn" class="active">On</button>
    </div>

    <script id="vs" type="x-shader/x-vertex">#version 300 es
in vec2 aPosition;
out vec2 vUV;
void main() {
    vUV = aPosition * 0.5 + 0.5;
    gl_Position = vec4(aPosition, 0.0, 1.0);
}</script>

    <script id="fs" type="x-shader/x-fragment">#version 300 es
precision highp float;
precision highp sampler3D;

in vec2 vUV;
out vec4 fragColor;

uniform sampler3D uVolume;
uniform mat3 uRotation;
uniform float uZoom;
uniform float uBrightness;
uniform float uThreshold;
uniform int uRenderMode;
uniform vec3 uAspect;
uniform vec2 uResolution;

const int MAX_STEPS = 512;
const float STEP_SIZE = 0.002;

vec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {
    vec3 tMin = (boxMin - rayOrigin) / rayDir;
    vec3 tMax = (boxMax - rayOrigin) / rayDir;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
}

void main() {
    vec2 uv = (vUV - 0.5) * 2.0;
    uv.x *= uResolution.x / uResolution.y;
    
    vec3 rayOrigin = vec3(0.0, 0.0, uZoom);
    vec3 rayDir = normalize(vec3(uv * 0.8, -1.0));
    
    rayOrigin = uRotation * rayOrigin;
    rayDir = uRotation * rayDir;
    
    vec3 boxMin = -uAspect * 0.5;
    vec3 boxMax = uAspect * 0.5;
    
    vec2 tHit = intersectAABB(rayOrigin, rayDir, boxMin, boxMax);
    
    if (tHit.x > tHit.y || tHit.y < 0.0) {
        fragColor = vec4(0.0, 0.0, 0.0, 1.0);
        return;
    }
    
    tHit.x = max(tHit.x, 0.0);
    
    float maxVal = 0.0;
    float accumAlpha = 0.0;
    float accumColor = 0.0;
    
    for (int i = 0; i < MAX_STEPS; i++) {
        float t = tHit.x + float(i) * STEP_SIZE;
        if (t > tHit.y) break;
        
        vec3 pos = rayOrigin + rayDir * t;
        vec3 texCoord = (pos - boxMin) / (boxMax - boxMin);
        float val = texture(uVolume, texCoord).r;
        
        val = max(0.0, val - uThreshold);
        
        if (uRenderMode == 0) {
            maxVal = max(maxVal, val);
        } else {
            float alpha = val * 0.08;
            accumColor += (1.0 - accumAlpha) * val * alpha;
            accumAlpha += (1.0 - accumAlpha) * alpha;
            if (accumAlpha > 0.95) break;
        }
    }
    
    float result = (uRenderMode == 0) ? maxVal : accumColor;
    result *= uBrightness;
    
    fragColor = vec4(result, result, result, 1.0);
}</script>

    <script>
    (function() {
        var canvas = document.getElementById("canvas");
        var gl = canvas.getContext("webgl2");
        
        if (!gl) {
            document.getElementById("loading").textContent = "WebGL2 not supported";
            return;
        }

        var volumeTexture;
        var program;
        var vao;
        var rotationX = 0.3;
        var rotationY = 0;
        var zoom = 2.0;
        var autoRotate = true;
        var renderMode = 0;
        var brightness = 2.0;
        var threshold = 0.02;
        var volumeDims = {x: 820, y: 650, z: 100};
        var aspectRatio = {x: 1.0, y: 0.793, z: 0.122};
        var lastTime = performance.now();
        var frameCount = 0;

        function createShader(type, sourceId) {
            var source = document.getElementById(sourceId).textContent;
            var shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error("Shader error:", gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function createProgram(vsId, fsId) {
            var vs = createShader(gl.VERTEX_SHADER, vsId);
            var fs = createShader(gl.FRAGMENT_SHADER, fsId);
            var prog = gl.createProgram();
            gl.attachShader(prog, vs);
            gl.attachShader(prog, fs);
            gl.linkProgram(prog);
            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                console.error("Program error:", gl.getProgramInfoLog(prog));
                return null;
            }
            return prog;
        }

        function loadVolume() {
            return fetch("volume_dims.json")
                .then(function(resp) { return resp.json(); })
                .then(function(dims) {
                    volumeDims = dims;
                    aspectRatio = {
                        x: dims.aspect_x || 1.0,
                        y: dims.aspect_y || 1.0,
                        z: dims.aspect_z || 1.0
                    };
                    
                    console.log("Volume dimensions:", dims);
                    document.getElementById("volSize").textContent = dims.z + " x " + dims.y + " x " + dims.x;
                    
                    return fetch("volume.raw");
                })
                .then(function(resp) { return resp.arrayBuffer(); })
                .then(function(buffer) {
                    var data = new Uint8Array(buffer);
                    var expectedSize = volumeDims.x * volumeDims.y * volumeDims.z;
                    console.log("Data size:", data.length, "Expected:", expectedSize);
                    
                    var minVal = 255, maxVal = 0;
                    for (var i = 0; i < data.length; i++) {
                        if (data[i] < minVal) minVal = data[i];
                        if (data[i] > maxVal) maxVal = data[i];
                    }
                    console.log("Data range:", minVal, "-", maxVal);
                    
                    volumeTexture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_3D, volumeTexture);
                    gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
                    
                    gl.texImage3D(
                        gl.TEXTURE_3D, 0, gl.R8,
                        volumeDims.x, volumeDims.y, volumeDims.z,
                        0, gl.RED, gl.UNSIGNED_BYTE, data
                    );
                    
                    console.log("Texture created");
                    return true;
                })
                .catch(function(e) {
                    console.error("Load error:", e);
                    document.getElementById("loading").textContent = "Error: " + e.message;
                    return false;
                });
        }

        function init() {
            program = createProgram("vs", "fs");
            
            var positions = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
            
            vao = gl.createVertexArray();
            gl.bindVertexArray(vao);
            
            var posBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
            
            var posLoc = gl.getAttribLocation(program, "aPosition");
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
        }

        function makeRotationMatrix(rx, ry) {
            var cx = Math.cos(rx), sx = Math.sin(rx);
            var cy = Math.cos(ry), sy = Math.sin(ry);
            return new Float32Array([
                cy,      0,   sy,
                sx*sy,   cx,  -sx*cy,
                -cx*sy,  sx,  cx*cy
            ]);
        }

        function render() {
            frameCount++;
            var now = performance.now();
            if (now - lastTime >= 1000) {
                document.getElementById("fps").textContent = frameCount;
                frameCount = 0;
                lastTime = now;
            }
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            if (autoRotate) {
                rotationY += 0.005;
            }
            
            gl.useProgram(program);
            gl.bindVertexArray(vao);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_3D, volumeTexture);
            gl.uniform1i(gl.getUniformLocation(program, "uVolume"), 0);
            
            gl.uniformMatrix3fv(gl.getUniformLocation(program, "uRotation"), false, makeRotationMatrix(rotationX, rotationY));
            gl.uniform1f(gl.getUniformLocation(program, "uZoom"), zoom);
            gl.uniform1f(gl.getUniformLocation(program, "uBrightness"), brightness);
            gl.uniform1f(gl.getUniformLocation(program, "uThreshold"), threshold);
            gl.uniform1i(gl.getUniformLocation(program, "uRenderMode"), renderMode);
            gl.uniform3f(gl.getUniformLocation(program, "uAspect"), aspectRatio.x, aspectRatio.y, aspectRatio.z);
            gl.uniform2f(gl.getUniformLocation(program, "uResolution"), canvas.width, canvas.height);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(render);
        }

        var isDragging = false;
        var lastMouseX, lastMouseY;

        canvas.addEventListener("mousedown", function(e) {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            autoRotate = false;
            document.getElementById("rotateBtn").classList.remove("active");
        });

        canvas.addEventListener("mousemove", function(e) {
            if (!isDragging) return;
            var dx = e.clientX - lastMouseX;
            var dy = e.clientY - lastMouseY;
            rotationY += dx * 0.01;
            rotationX += dy * 0.01;
            rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotationX));
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener("mouseup", function() { isDragging = false; });
        canvas.addEventListener("mouseleave", function() { isDragging = false; });

        canvas.addEventListener("wheel", function(e) {
            e.preventDefault();
            zoom *= e.deltaY > 0 ? 1.1 : 0.9;
            zoom = Math.max(0.5, Math.min(5, zoom));
        });

        canvas.addEventListener("touchstart", function(e) {
            if (e.touches.length === 1) {
                isDragging = true;
                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;
                autoRotate = false;
            }
        });

        canvas.addEventListener("touchmove", function(e) {
            e.preventDefault();
            if (isDragging && e.touches.length === 1) {
                var dx = e.touches[0].clientX - lastMouseX;
                var dy = e.touches[0].clientY - lastMouseY;
                rotationY += dx * 0.01;
                rotationX += dy * 0.01;
                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;
            }
        });

        canvas.addEventListener("touchend", function() { isDragging = false; });

        document.getElementById("brightness").addEventListener("input", function(e) {
            brightness = parseFloat(e.target.value);
            document.getElementById("brightnessVal").textContent = brightness.toFixed(1);
        });

        document.getElementById("threshold").addEventListener("input", function(e) {
            threshold = parseFloat(e.target.value);
            document.getElementById("thresholdVal").textContent = threshold.toFixed(2);
        });

        document.getElementById("mipBtn").addEventListener("click", function() {
            renderMode = 0;
            document.getElementById("mipBtn").classList.add("active");
            document.getElementById("alphaBtn").classList.remove("active");
        });

        document.getElementById("alphaBtn").addEventListener("click", function() {
            renderMode = 1;
            document.getElementById("alphaBtn").classList.add("active");
            document.getElementById("mipBtn").classList.remove("active");
        });

        document.getElementById("rotateBtn").addEventListener("click", function() {
            autoRotate = !autoRotate;
            document.getElementById("rotateBtn").classList.toggle("active", autoRotate);
        });

        init();
        loadVolume().then(function(loaded) {
            if (loaded) {
                document.getElementById("loading").style.display = "none";
                document.getElementById("info").style.display = "block";
                document.getElementById("controls").style.display = "block";
                render();
            }
        });
    })();
    </script>
</body>
</html>
